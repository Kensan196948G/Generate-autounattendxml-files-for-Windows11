# Windows 11 Sysprep応答ファイル自動生成システム（PowerShell版）
## トラブルシューティングガイド

### 目次
1. [よくある問題と解決方法](#よくある問題と解決方法)
2. [エラーメッセージ一覧](#エラーメッセージ一覧)
3. [ログファイルの読み方](#ログファイルの読み方)
4. [問題解決フローチャート](#問題解決フローチャート)
5. [診断ツールとスクリプト](#診断ツールとスクリプト)
6. [パフォーマンス問題の対処](#パフォーマンス問題の対処)
7. [システム要件関連の問題](#システム要件関連の問題)
8. [サポートとヘルプの入手方法](#サポートとヘルプの入手方法)

---

## よくある問題と解決方法

### 問題カテゴリ別インデックス

| 問題カテゴリ | 頻度 | 影響度 | 解決難易度 |
|-------------|------|--------|-----------|
| [PowerShell実行ポリシー](#powershell実行ポリシー関連) | 高 | 高 | 低 |
| [モジュール読み込みエラー](#モジュール読み込みエラー) | 高 | 高 | 中 |
| [ファイル権限エラー](#ファイル権限エラー) | 中 | 中 | 中 |
| [設定ファイル構文エラー](#設定ファイル構文エラー) | 中 | 中 | 低 |
| [XML生成エラー](#xml生成エラー) | 低 | 高 | 高 |
| [パフォーマンス問題](#パフォーマンス問題) | 低 | 低 | 中 |

---

## PowerShell実行ポリシー関連

### 問題1: スクリプト実行が無効になっている

#### 症状
```
.\Generate-UnattendXML.ps1 : このシステムではスクリプトの実行が無効になっているため、
ファイル Generate-UnattendXML.ps1 を読み込めません。
```

#### 原因
- PowerShellの実行ポリシーが制限されている
- 最も一般的な初回実行時エラー

#### 解決方法

##### 方法1: 一時的な解決（推奨）
```powershell
# 現在のセッションのみで実行ポリシーを緩和
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process

# スクリプト実行
.\Generate-UnattendXML.ps1 -PresetName Development
```

##### 方法2: ユーザー単位での設定変更
```powershell
# 現在のユーザーの実行ポリシーを変更
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

# 設定確認
Get-ExecutionPolicy -List
```

##### 方法3: システム全体での設定変更（管理者権限必要）
```powershell
# 管理者権限でPowerShellを起動
Start-Process PowerShell -Verb RunAs

# システム全体の実行ポリシー変更
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope LocalMachine
```

#### 予防策
- インストール時に適切な実行ポリシーを設定
- 実行バッチファイルを作成して自動化

```batch
@echo off
powershell -ExecutionPolicy Bypass -File "Generate-UnattendXML.ps1" -PresetName Enterprise
pause
```

---

### 問題2: デジタル署名の検証エラー

#### 症状
```
ファイル Generate-UnattendXML.ps1 はデジタル署名されていません。
このスクリプトは信頼できない発行者からのものである可能性があります。
```

#### 解決方法

##### 方法1: ファイルのブロック解除
```powershell
# PowerShellスクリプトのブロック解除
Unblock-File -Path ".\Generate-UnattendXML.ps1"
Unblock-File -Path ".\Generate-UnattendXML.psm1"

# モジュールファイルのブロック解除
Get-ChildItem -Path ".\Modules" -Recurse -Filter "*.psm1" | Unblock-File
```

##### 方法2: 一括ブロック解除スクリプト
```powershell
# unblock-all.ps1
$scriptPath = $PSScriptRoot
$filesToUnblock = @(
    "*.ps1",
    "*.psm1", 
    "*.psd1"
)

foreach ($pattern in $filesToUnblock) {
    Get-ChildItem -Path $scriptPath -Recurse -Filter $pattern | ForEach-Object {
        Unblock-File -Path $_.FullName
        Write-Host "ブロック解除: $($_.Name)" -ForegroundColor Green
    }
}
```

---

## モジュール読み込みエラー

### 問題3: モジュールが見つからない

#### 症状
```
Import-Module : 指定されたモジュール 'Generate-UnattendXML.psm1' が読み込まれませんでした。
モジュール 'Generate-UnattendXML.psm1' が見つからないため、読み込めませんでした。
```

#### 原因
- ファイルパスの問題
- モジュールファイルの破損または不存在
- 権限問題

#### 診断手順

##### Step 1: ファイル存在確認
```powershell
# メインモジュールの存在確認
Test-Path ".\Generate-UnattendXML.psm1"

# 必要なファイルの一括確認
$requiredFiles = @(
    ".\Generate-UnattendXML.ps1",
    ".\Generate-UnattendXML.psm1",
    ".\Modules\UserManagement\UserManagement.psm1",
    ".\Modules\NetworkConfig\NetworkConfig.psm1",
    ".\Modules\WindowsFeatures\WindowsFeatures.psm1",
    ".\Modules\ApplicationConfig\ApplicationConfig.psm1",
    ".\Modules\XMLGenerator\XMLGenerator.psm1"
)

foreach ($file in $requiredFiles) {
    if (Test-Path $file) {
        Write-Host "✅ $file" -ForegroundColor Green
    } else {
        Write-Host "❌ $file が見つかりません" -ForegroundColor Red
    }
}
```

##### Step 2: ファイル権限確認
```powershell
# ファイル権限の確認
$file = ".\Generate-UnattendXML.psm1"
$acl = Get-Acl $file
$acl.Access | Select-Object IdentityReference, FileSystemRights, AccessControlType
```

#### 解決方法

##### 方法1: パス問題の解決
```powershell
# 現在のディレクトリ確認
Get-Location

# スクリプトのあるディレクトリに移動
Set-Location "C:\Tools\Windows11-UnattendXML-Generator"

# 絶対パスでインポート
Import-Module "$PWD\Generate-UnattendXML.psm1" -Force
```

##### 方法2: 権限修正
```powershell
# ファイル権限の修正
$files = Get-ChildItem -Recurse -Filter "*.psm1"
foreach ($file in $files) {
    $acl = Get-Acl $file.FullName
    $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule(
        $env:USERNAME, "FullControl", "Allow"
    )
    $acl.SetAccessRule($accessRule)
    Set-Acl $file.FullName $acl
    Write-Host "権限修正: $($file.Name)" -ForegroundColor Yellow
}
```

---

### 問題4: 依存モジュールの読み込み失敗

#### 症状
```
Import-Module : 次のアセンブリまたはモジュールを読み込めませんでした: 'System.Xml'
ファイルまたはアセンブリ、またはその依存関係の 1 つが見つかりませんでした。
```

#### 原因
- .NET Framework バージョン不足
- 破損したアセンブリ
- システムファイルの問題

#### 解決方法

##### 方法1: .NET Framework確認と修復
```powershell
# .NET Framework バージョン確認
[System.Environment]::Version
Get-ItemProperty "HKLM:SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\" -Name Release

# 必要な.NETアセンブリのテスト読み込み
try {
    Add-Type -AssemblyName System.Xml
    Add-Type -AssemblyName System.Security
    Add-Type -AssemblyName System.Management.Automation
    Write-Host "✅ 必要なアセンブリは正常に読み込まれました" -ForegroundColor Green
} catch {
    Write-Host "❌ アセンブリ読み込みエラー: $_" -ForegroundColor Red
}
```

##### 方法2: 最小限モジュールでのテスト
```powershell
# 単純なテストモジュール作成
$testModule = @"
function Test-BasicFunctionality {
    try {
        [xml]`$testXml = '<test></test>'
        Write-Host "XML処理: OK"
        
        `$secureString = ConvertTo-SecureString "test" -AsPlainText -Force
        Write-Host "SecureString処理: OK"
        
        return `$true
    } catch {
        Write-Host "エラー: `$_"
        return `$false
    }
}
"@

$testModule | Out-File "TestModule.psm1" -Encoding UTF8
Import-Module ".\TestModule.psm1" -Force
Test-BasicFunctionality
Remove-Item "TestModule.psm1" -Force
```

---

## ファイル権限エラー

### 問題5: 出力ファイルへのアクセス拒否

#### 症状
```
Add-Content : パス 'C:\Tools\...\Outputs\unattend.xml' へのアクセスが拒否されました。
```

#### 原因
- 出力ディレクトリの書き込み権限不足
- ファイルが他のプロセスで使用中
- ファイルシステムの問題

#### 診断手順

```powershell
# 権限診断スクリプト
function Test-DirectoryPermissions {
    param([string]$Path)
    
    try {
        # ディレクトリ存在確認
        if (!(Test-Path $Path)) {
            Write-Host "ディレクトリが存在しません: $Path" -ForegroundColor Red
            return $false
        }
        
        # 書き込みテスト
        $testFile = Join-Path $Path "permission-test.tmp"
        "test" | Out-File $testFile -ErrorAction Stop
        Remove-Item $testFile -Force
        
        Write-Host "✅ 書き込み権限OK: $Path" -ForegroundColor Green
        return $true
    }
    catch {
        Write-Host "❌ 権限エラー: $Path - $_" -ForegroundColor Red
        return $false
    }
}

# 主要ディレクトリの権限テスト
$directories = @(".\Outputs", ".\Logs", ".\Configs")
foreach ($dir in $directories) {
    Test-DirectoryPermissions -Path $dir
}
```

#### 解決方法

##### 方法1: ディレクトリ権限の修正
```powershell
# 権限修正スクリプト
function Set-DirectoryPermissions {
    param([string]$Path)
    
    try {
        # ディレクトリ作成（存在しない場合）
        if (!(Test-Path $Path)) {
            New-Item -Path $Path -ItemType Directory -Force | Out-Null
        }
        
        # アクセス制御リスト取得
        $acl = Get-Acl $Path
        
        # フルコントロール権限を追加
        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule(
            $env:USERNAME,
            "FullControl",
            "ContainerInherit,ObjectInherit",
            "None",
            "Allow"
        )
        
        $acl.SetAccessRule($accessRule)
        Set-Acl $Path $acl
        
        Write-Host "✅ 権限設定完了: $Path" -ForegroundColor Green
    }
    catch {
        Write-Host "❌ 権限設定失敗: $Path - $_" -ForegroundColor Red
    }
}

# 必要なディレクトリの権限設定
@(".\Outputs", ".\Logs", ".\Configs") | ForEach-Object {
    Set-DirectoryPermissions -Path $_
}
```

##### 方法2: 管理者権限での実行
```powershell
# 管理者権限チェック
function Test-Administrator {
    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

if (!(Test-Administrator)) {
    Write-Host "管理者権限が必要です。管理者として PowerShell を実行してください。" -ForegroundColor Yellow
    
    # 管理者権限で再実行
    $scriptPath = $MyInvocation.MyCommand.Path
    Start-Process PowerShell -Verb RunAs -ArgumentList "-File `"$scriptPath`""
    exit
}
```

---

### 問題6: ファイルロックエラー

#### 症状
```
Set-Content : ファイル 'unattend.xml' は別のプロセスによって使用されているため、
プロセスはファイルにアクセスできません。
```

#### 原因
- XMLファイルがテキストエディターやビューアーで開かれている
- 他のプロセスがファイルを使用中

#### 解決方法

##### 方法1: プロセス確認と終了
```powershell
# ファイルを使用しているプロセスの確認
function Get-FileProcess {
    param([string]$FilePath)
    
    try {
        $processes = Get-Process | Where-Object {
            try {
                $_.Modules | Where-Object { $_.FileName -eq $FilePath }
            } catch { }
        }
        
        if ($processes) {
            Write-Host "ファイルを使用中のプロセス:" -ForegroundColor Yellow
            $processes | Select-Object Name, Id, ProcessName | Format-Table
        } else {
            Write-Host "ファイルを使用中のプロセスは見つかりませんでした" -ForegroundColor Green
        }
    }
    catch {
        Write-Host "プロセス確認エラー: $_" -ForegroundColor Red
    }
}

# 使用例
Get-FileProcess -FilePath "C:\Path\To\unattend.xml"
```

##### 方法2: 強制上書きオプション
```powershell
# Force パラメーターの使用
.\Generate-UnattendXML.ps1 -PresetName Enterprise -OutputPath ".\Outputs\unattend.xml" -Force

# または一意なファイル名での生成
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
.\Generate-UnattendXML.ps1 -PresetName Enterprise -OutputPath ".\Outputs\unattend_$timestamp.xml"
```

---

## 設定ファイル構文エラー

### 問題7: PSD1ファイル構文エラー

#### 症状
```
Import-PowerShellDataFile : データファイルの読み込みでエラーが発生しました
'C:\...\custom.psd1': ハッシュテーブルの構文が正しくありません。
```

#### 原因
- PSD1ファイルの構文エラー
- 不正な文字の混入
- エンコーディング問題

#### 診断手順

```powershell
# PSD1ファイル構文チェッカー
function Test-PSD1Syntax {
    param([string]$FilePath)
    
    try {
        Write-Host "PSD1構文チェック: $FilePath" -ForegroundColor Yellow
        
        # ファイル読み込みテスト
        $content = Get-Content $FilePath -Raw -Encoding UTF8
        
        # 基本構文チェック
        if ($content -notmatch "^@{.*}$") {
            Write-Host "❌ PSD1形式でない可能性があります" -ForegroundColor Red
        }
        
        # インポートテスト
        $data = Import-PowerShellDataFile -Path $FilePath
        Write-Host "✅ 構文チェック成功" -ForegroundColor Green
        
        # 必須セクション確認
        $requiredSections = @("System", "Users")
        foreach ($section in $requiredSections) {
            if ($data.ContainsKey($section)) {
                Write-Host "✅ 必須セクション確認: $section" -ForegroundColor Green
            } else {
                Write-Host "⚠️ 推奨セクション不足: $section" -ForegroundColor Yellow
            }
        }
        
        return $true
    }
    catch {
        Write-Host "❌ 構文エラー: $_" -ForegroundColor Red
        
        # 詳細エラー情報
        if ($_.Exception.Message -match "行 (\d+)") {
            $lineNumber = $matches[1]
            Write-Host "エラー行: $lineNumber" -ForegroundColor Red
            
            # 該当行周辺の表示
            $lines = Get-Content $FilePath
            $start = [Math]::Max(0, $lineNumber - 3)
            $end = [Math]::Min($lines.Count - 1, $lineNumber + 2)
            
            for ($i = $start; $i -le $end; $i++) {
                $marker = if ($i -eq ($lineNumber - 1)) { ">>>" } else { "   " }
                Write-Host "$marker $($i + 1): $($lines[$i])" -ForegroundColor Gray
            }
        }
        
        return $false
    }
}

# 使用例
Test-PSD1Syntax -FilePath ".\Configs\Presets\Enterprise.psd1"
```

#### よくある構文エラーと修正例

##### エラー1: カンマの不足・過多
```powershell
# ❌ 誤り: カンマ不足
Users = @(
    @{ Name = "user1"; Password = "pass1" }  # カンマなし
    @{ Name = "user2"; Password = "pass2" }
)

# ✅ 正しい
Users = @(
    @{ Name = "user1"; Password = "pass1" },  # カンマ必要
    @{ Name = "user2"; Password = "pass2" }   # 最後はカンマ不要
)
```

##### エラー2: クォートの問題
```powershell
# ❌ 誤り: シングルクォート内のシングルクォート
Description = 'User's account'  # エラー

# ✅ 正しい方法
Description = "User's account"        # ダブルクォート使用
Description = 'User''s account'       # エスケープ
Description = 'User`'s account'       # バッククォートエスケープ
```

##### エラー3: ブール値の記述
```powershell
# ❌ 誤り: 文字列としてのブール値
DisableIPv6 = "true"    # 文字列になってしまう

# ✅ 正しい
DisableIPv6 = $true     # PowerShellブール値
```

---

### 問題8: JSON設定ファイルエラー

#### 症状
```
ConvertFrom-Json : JSON文字列に無効な文字があります。
```

#### JSON構文チェッカー

```powershell
function Test-JSONSyntax {
    param([string]$FilePath)
    
    try {
        Write-Host "JSON構文チェック: $FilePath" -ForegroundColor Yellow
        
        # JSON読み込みテスト
        $content = Get-Content $FilePath -Raw -Encoding UTF8
        $data = $content | ConvertFrom-Json
        
        Write-Host "✅ JSON構文チェック成功" -ForegroundColor Green
        
        # 構造確認
        $requiredProps = @("System", "Users")
        foreach ($prop in $requiredProps) {
            if ($data.PSObject.Properties.Name -contains $prop) {
                Write-Host "✅ 必須プロパティ確認: $prop" -ForegroundColor Green
            } else {
                Write-Host "⚠️ 推奨プロパティ不足: $prop" -ForegroundColor Yellow
            }
        }
        
        return $true
    }
    catch {
        Write-Host "❌ JSON構文エラー: $_" -ForegroundColor Red
        
        # エラー位置の特定
        if ($_.Exception.Message -match "位置 (\d+)") {
            $position = [int]$matches[1]
            $content = Get-Content $FilePath -Raw
            
            # エラー位置周辺の表示
            $start = [Math]::Max(0, $position - 50)
            $end = [Math]::Min($content.Length, $position + 50)
            $context = $content.Substring($start, $end - $start)
            
            Write-Host "エラー位置周辺:" -ForegroundColor Yellow
            Write-Host $context -ForegroundColor Gray
        }
        
        return $false
    }
}
```

---

## XML生成エラー

### 問題9: XML形式エラー

#### 症状
```
System.Xml.XmlException: 不正な文字が含まれています
```

#### 原因
- 特殊文字のエスケープ不足
- 不正なXML構造
- エンコーディング問題

#### 解決方法

```powershell
# XML検証ツール
function Test-XMLGeneration {
    param(
        [string]$PresetName,
        [string]$OutputPath = "test-output.xml"
    )
    
    try {
        Write-Host "XML生成テスト開始: $PresetName" -ForegroundColor Yellow
        
        # テストファイル生成
        $result = .\Generate-UnattendXML.ps1 -PresetName $PresetName -OutputPath $OutputPath -Force
        
        if (Test-Path $result) {
            # XML妥当性確認
            [xml]$xmlDoc = Get-Content $result -Raw -Encoding UTF8
            
            Write-Host "✅ XML生成成功: $result" -ForegroundColor Green
            Write-Host "   ファイルサイズ: $((Get-Item $result).Length) bytes" -ForegroundColor Gray
            Write-Host "   ルート要素: $($xmlDoc.DocumentElement.LocalName)" -ForegroundColor Gray
            
            # 基本構造確認
            if ($xmlDoc.unattend -ne $null) {
                Write-Host "✅ unattend要素確認済み" -ForegroundColor Green
                
                $settingsCount = ($xmlDoc.unattend.settings | Measure-Object).Count
                Write-Host "   settings要素数: $settingsCount" -ForegroundColor Gray
            } else {
                Write-Host "❌ unattend要素が見つかりません" -ForegroundColor Red
            }
            
            # テストファイル削除
            Remove-Item $result -Force
            
            return $true
        } else {
            Write-Host "❌ XMLファイル生成失敗" -ForegroundColor Red
            return $false
        }
    }
    catch {
        Write-Host "❌ XML生成エラー: $_" -ForegroundColor Red
        
        # 詳細エラー情報
        if ($_.Exception.InnerException) {
            Write-Host "内部エラー: $($_.Exception.InnerException.Message)" -ForegroundColor Red
        }
        
        return $false
    }
}

# 全プリセットのテスト
@("Development", "Enterprise", "Minimal") | ForEach-Object {
    Test-XMLGeneration -PresetName $_
    Write-Host ""
}
```

---

### 問題10: 並列処理エラー

#### 症状
```
RunspacePoolのジョブでエラーが発生しました
```

#### 原因
- メモリ不足
- 並列度が高すぎる
- モジュール依存関係の問題

#### 解決方法

```powershell
# 並列処理の診断とチューニング
function Test-ParallelProcessing {
    Write-Host "並列処理診断開始" -ForegroundColor Yellow
    
    # システムリソース確認
    $cpu = (Get-WmiObject Win32_Processor).NumberOfLogicalProcessors
    $memory = [Math]::Round((Get-WmiObject Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2)
    
    Write-Host "CPU論理コア数: $cpu" -ForegroundColor Gray
    Write-Host "物理メモリ: ${memory}GB" -ForegroundColor Gray
    
    # 推奨並列度計算
    $recommendedParallel = [Math]::Min($cpu, 4)  # 最大4並列
    Write-Host "推奨並列度: $recommendedParallel" -ForegroundColor Green
    
    # メモリ使用量監視付きテスト
    try {
        Write-Host "並列処理テスト実行中..." -ForegroundColor Yellow
        
        $startMemory = [System.GC]::GetTotalMemory($false)
        
        # テスト用軽量設定で並列実行
        $jobs = @()
        for ($i = 1; $i -le $recommendedParallel; $i++) {
            $job = Start-Job -ScriptBlock {
                param($ScriptPath, $Index)
                & "$ScriptPath\Generate-UnattendXML.ps1" -PresetName "Minimal" -OutputPath "test-parallel-$Index.xml" -Force
            } -ArgumentList $PWD, $i
            
            $jobs += $job
        }
        
        # ジョブ完了待ち
        $jobs | Wait-Job
        
        # 結果確認
        $successCount = 0
        foreach ($job in $jobs) {
            $result = Receive-Job $job
            if ($job.State -eq "Completed") {
                $successCount++
            } else {
                Write-Host "ジョブエラー: $($job.State)" -ForegroundColor Red
            }
            Remove-Job $job
        }
        
        $endMemory = [System.GC]::GetTotalMemory($false)
        $memoryIncrease = [Math]::Round(($endMemory - $startMemory) / 1MB, 2)
        
        Write-Host "✅ 並列処理テスト完了" -ForegroundColor Green
        Write-Host "   成功ジョブ: $successCount / $($jobs.Count)" -ForegroundColor Gray
        Write-Host "   メモリ増加: ${memoryIncrease}MB" -ForegroundColor Gray
        
        # テストファイルクリーンアップ
        Get-ChildItem -Filter "test-parallel-*.xml" | Remove-Item -Force
        
    } catch {
        Write-Host "❌ 並列処理テスト失敗: $_" -ForegroundColor Red
    }
}

Test-ParallelProcessing
```

---

## ログファイルの読み方

### ログファイルの場所と形式

#### 標準的なログファイルパス
```
.\Logs\Generate-UnattendXML_yyyyMMdd_HHmmss.log
.\Logs\UnattendGeneration_yyyyMMdd_HHmmss.log
```

#### ログエントリ形式
```
[yyyy-MM-dd HH:mm:ss] [LogLevel] メッセージ内容
```

### ログレベルの意味

| レベル | 用途 | 対応すべき緊急度 |
|--------|------|------------------|
| `Debug` | 詳細なデバッグ情報 | 低 |
| `Info` | 通常の情報メッセージ | 低 |
| `Warning` | 警告（処理は継続） | 中 |
| `Error` | エラー（処理に影響） | 高 |
| `Critical` | 致命的エラー | 最高 |

### ログ解析ツール

```powershell
# ログ解析スクリプト
function Analyze-LogFile {
    param(
        [string]$LogPath,
        [string]$LogLevel = "All",
        [int]$TailLines = 50
    )
    
    if (!(Test-Path $LogPath)) {
        Write-Host "ログファイルが見つかりません: $LogPath" -ForegroundColor Red
        return
    }
    
    $logContent = Get-Content $LogPath
    
    # ログレベル別フィルタリング
    if ($LogLevel -ne "All") {
        $logContent = $logContent | Where-Object { $_ -match "\[$LogLevel\]" }
    }
    
    # 最新N行の表示
    $displayLines = $logContent | Select-Object -Last $TailLines
    
    Write-Host "=== ログ解析結果 ===" -ForegroundColor Cyan
    Write-Host "ファイル: $LogPath" -ForegroundColor Yellow
    Write-Host "フィルタ: $LogLevel" -ForegroundColor Yellow
    Write-Host "表示行数: $($displayLines.Count)" -ForegroundColor Yellow
    Write-Host ""
    
    foreach ($line in $displayLines) {
        # レベルに応じた色分け表示
        if ($line -match "\[Error\]|\[Critical\]") {
            Write-Host $line -ForegroundColor Red
        } elseif ($line -match "\[Warning\]") {
            Write-Host $line -ForegroundColor Yellow
        } elseif ($line -match "\[Debug\]") {
            Write-Host $line -ForegroundColor Gray
        } else {
            Write-Host $line -ForegroundColor White
        }
    }
    
    Write-Host ""
    
    # 統計情報
    $stats = @{}
    $allContent = Get-Content $LogPath
    
    @("Debug", "Info", "Warning", "Error", "Critical") | ForEach-Object {
        $level = $_
        $count = ($allContent | Where-Object { $_ -match "\[$level\]" } | Measure-Object).Count
        $stats[$level] = $count
    }
    
    Write-Host "=== ログレベル統計 ===" -ForegroundColor Cyan
    $stats.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {
        $color = switch ($_.Key) {
            "Critical" { "Red" }
            "Error" { "Red" }
            "Warning" { "Yellow" }
            "Info" { "Green" }
            "Debug" { "Gray" }
        }
        Write-Host "$($_.Key): $($_.Value)" -ForegroundColor $color
    }
}

# 最新ログファイルの自動解析
function Analyze-LatestLog {
    param(
        [string]$LogLevel = "All",
        [int]$TailLines = 50
    )
    
    $logDir = ".\Logs"
    if (!(Test-Path $logDir)) {
        Write-Host "ログディレクトリが見つかりません: $logDir" -ForegroundColor Red
        return
    }
    
    $latestLog = Get-ChildItem $logDir -Filter "*.log" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    
    if ($latestLog) {
        Analyze-LogFile -LogPath $latestLog.FullName -LogLevel $LogLevel -TailLines $TailLines
    } else {
        Write-Host "ログファイルが見つかりません" -ForegroundColor Red
    }
}

# 使用例
# Analyze-LatestLog -LogLevel "Error" -TailLines 20
# Analyze-LogFile -LogPath ".\Logs\Generate-UnattendXML_20250122_143052.log"
```

### よくあるログエラーパターン

#### パターン1: モジュール読み込み失敗
```
[2025-01-22 14:30:52] [Error] モジュールインポートエラー [UserManagement]: 
指定されたモジュール 'UserManagement.psm1' が読み込まれませんでした
```
**対処法**: モジュールファイルの存在確認、権限確認

#### パターン2: 設定ファイル問題
```
[2025-01-22 14:31:15] [Error] プリセット読み込みエラー: 
データファイルの読み込みでエラーが発生しました 'Enterprise.psd1'
```
**対処法**: 設定ファイルの構文確認

#### パターン3: XML生成失敗
```
[2025-01-22 14:31:45] [Critical] UnattendXML生成エラー: 
System.Xml.XmlException: 不正な文字が含まれています
```
**対処法**: 入力データの文字確認、エンコーディング確認

---

## 問題解決フローチャート

### 1. 初期診断フロー

```
[実行開始]
    ↓
[エラー発生?] → No → [正常終了]
    ↓ Yes
[エラー種別判定]
    ↓
├─[PowerShell実行ポリシー?] → [実行ポリシー変更手順]
├─[モジュール読み込みエラー?] → [ファイル存在・権限確認]
├─[ファイル権限エラー?] → [権限修正手順]
├─[設定ファイルエラー?] → [構文チェック手順]
├─[XML生成エラー?] → [詳細ログ解析]
└─[その他] → [総合診断スクリプト実行]
```

### 2. 段階的診断手順

#### Level 1: 基本確認
```powershell
# Level 1診断スクリプト
function Test-Level1Diagnosis {
    Write-Host "=== Level 1: 基本診断 ===" -ForegroundColor Cyan
    
    # PowerShellバージョン
    Write-Host "PowerShell バージョン: $($PSVersionTable.PSVersion)" -ForegroundColor Green
    
    # 実行ポリシー
    Write-Host "実行ポリシー: $(Get-ExecutionPolicy)" -ForegroundColor Green
    
    # 管理者権限
    $isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")
    Write-Host "管理者権限: $isAdmin" -ForegroundColor $(if($isAdmin) {"Green"} else {"Yellow"})
    
    # 基本ファイル存在確認
    $mainScript = ".\Generate-UnattendXML.ps1"
    Write-Host "メインスクリプト: $(Test-Path $mainScript)" -ForegroundColor $(if(Test-Path $mainScript) {"Green"} else {"Red"})
    
    $mainModule = ".\Generate-UnattendXML.psm1"
    Write-Host "メインモジュール: $(Test-Path $mainModule)" -ForegroundColor $(if(Test-Path $mainModule) {"Green"} else {"Red"})
    
    return @{
        PowerShellVersion = $PSVersionTable.PSVersion
        ExecutionPolicy = Get-ExecutionPolicy
        IsAdmin = $isAdmin
        MainScriptExists = Test-Path $mainScript
        MainModuleExists = Test-Path $mainModule
    }
}
```

#### Level 2: 詳細確認
```powershell
# Level 2診断スクリプト
function Test-Level2Diagnosis {
    Write-Host "=== Level 2: 詳細診断 ===" -ForegroundColor Cyan
    
    # 全モジュールファイル確認
    $moduleFiles = @(
        ".\Modules\UserManagement\UserManagement.psm1",
        ".\Modules\NetworkConfig\NetworkConfig.psm1",
        ".\Modules\WindowsFeatures\WindowsFeatures.psm1",
        ".\Modules\ApplicationConfig\ApplicationConfig.psm1",
        ".\Modules\XMLGenerator\XMLGenerator.psm1"
    )
    
    $missingModules = @()
    foreach ($module in $moduleFiles) {
        if (Test-Path $module) {
            Write-Host "✅ $module" -ForegroundColor Green
        } else {
            Write-Host "❌ $module" -ForegroundColor Red
            $missingModules += $module
        }
    }
    
    # プリセットファイル確認
    $presetFiles = @(
        ".\Configs\Presets\Development.psd1",
        ".\Configs\Presets\Enterprise.psd1",
        ".\Configs\Presets\Minimal.psd1"
    )
    
    $missingPresets = @()
    foreach ($preset in $presetFiles) {
        if (Test-Path $preset) {
            Write-Host "✅ $preset" -ForegroundColor Green
        } else {
            Write-Host "❌ $preset" -ForegroundColor Red
            $missingPresets += $preset
        }
    }
    
    # .NET アセンブリ確認
    try {
        Add-Type -AssemblyName System.Xml
        Add-Type -AssemblyName System.Security
        Write-Host "✅ 必要な.NETアセンブリ利用可能" -ForegroundColor Green
    } catch {
        Write-Host "❌ .NETアセンブリエラー: $_" -ForegroundColor Red
    }
    
    return @{
        MissingModules = $missingModules
        MissingPresets = $missingPresets
        DotNetAvailable = $true  # 簡略化
    }
}
```

#### Level 3: 機能テスト
```powershell
# Level 3診断スクリプト
function Test-Level3Diagnosis {
    Write-Host "=== Level 3: 機能テスト ===" -ForegroundColor Cyan
    
    try {
        # モジュールインポートテスト
        Import-Module ".\Generate-UnattendXML.psm1" -Force -ErrorAction Stop
        Write-Host "✅ メインモジュールインポート成功" -ForegroundColor Green
        
        # プリセット読み込みテスト
        $testPreset = Import-UnattendPreset -PresetName "Development"
        Write-Host "✅ プリセット読み込み成功" -ForegroundColor Green
        
        # XML生成テスト（WhatIfモード）
        $result = .\Generate-UnattendXML.ps1 -PresetName "Development" -WhatIf
        Write-Host "✅ WhatIfテスト成功" -ForegroundColor Green
        
        return @{
            ModuleImport = $true
            PresetLoad = $true
            WhatIfTest = $true
        }
        
    } catch {
        Write-Host "❌ 機能テスト失敗: $_" -ForegroundColor Red
        return @{
            ModuleImport = $false
            PresetLoad = $false
            WhatIfTest = $false
            Error = $_.Exception.Message
        }
    }
}
```

### 3. 統合診断スクリプト

```powershell
# 完全診断スクリプト
function Start-CompleteDiagnosis {
    param(
        [switch]$Detailed,
        [switch]$AutoFix
    )
    
    Write-Host "=== Windows 11 UnattendXML Generator 診断開始 ===" -ForegroundColor Cyan
    Write-Host "診断時刻: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')" -ForegroundColor Yellow
    Write-Host ""
    
    # Level 1診断
    $level1 = Test-Level1Diagnosis
    Write-Host ""
    
    # 致命的問題のチェック
    $criticalIssues = @()
    
    if (!$level1.MainScriptExists) {
        $criticalIssues += "メインスクリプトが見つかりません"
    }
    
    if (!$level1.MainModuleExists) {
        $criticalIssues += "メインモジュールが見つかりません"
    }
    
    if ($level1.ExecutionPolicy -eq "Restricted") {
        $criticalIssues += "PowerShell実行ポリシーが制限されています"
    }
    
    if ($criticalIssues.Count -gt 0) {
        Write-Host "=== 致命的な問題が検出されました ===" -ForegroundColor Red
        foreach ($issue in $criticalIssues) {
            Write-Host "❌ $issue" -ForegroundColor Red
        }
        
        if ($AutoFix) {
            Write-Host "自動修復を試行します..." -ForegroundColor Yellow
            # 自動修復ロジック（簡略化）
        } else {
            Write-Host "修復するには -AutoFix パラメーターを使用してください" -ForegroundColor Yellow
        }
        return
    }
    
    # Level 2診断
    if ($Detailed) {
        $level2 = Test-Level2Diagnosis
        Write-Host ""
        
        # Level 3診断
        $level3 = Test-Level3Diagnosis
        Write-Host ""
    }
    
    Write-Host "=== 診断完了 ===" -ForegroundColor Green
    Write-Host "システムは正常に動作する可能性が高いです" -ForegroundColor Green
}

# 使用例
# Start-CompleteDiagnosis -Detailed
# Start-CompleteDiagnosis -AutoFix
```

---

## 診断ツールとスクリプト

### 自動修復スクリプト

```powershell
# 自動修復スクリプト
function Repair-UnattendXMLGenerator {
    param(
        [switch]$ExecutionPolicy,
        [switch]$FilePermissions,
        [switch]$MissingFiles,
        [switch]$All
    )
    
    Write-Host "=== 自動修復開始 ===" -ForegroundColor Cyan
    
    if ($All -or $ExecutionPolicy) {
        Write-Host "PowerShell実行ポリシー修復中..." -ForegroundColor Yellow
        try {
            Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force
            Write-Host "✅ 実行ポリシー修復完了" -ForegroundColor Green
        } catch {
            Write-Host "❌ 実行ポリシー修復失敗: $_" -ForegroundColor Red
        }
    }
    
    if ($All -or $FilePermissions) {
        Write-Host "ファイル権限修復中..." -ForegroundColor Yellow
        try {
            @(".\Outputs", ".\Logs", ".\Configs") | ForEach-Object {
                if (!(Test-Path $_)) {
                    New-Item -Path $_ -ItemType Directory -Force | Out-Null
                }
                
                $acl = Get-Acl $_
                $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule(
                    $env:USERNAME, "FullControl", "ContainerInherit,ObjectInherit", "None", "Allow"
                )
                $acl.SetAccessRule($accessRule)
                Set-Acl $_ $acl
            }
            Write-Host "✅ ファイル権限修復完了" -ForegroundColor Green
        } catch {
            Write-Host "❌ ファイル権限修復失敗: $_" -ForegroundColor Red
        }
    }
    
    if ($All -or $MissingFiles) {
        Write-Host "不足ファイル確認中..." -ForegroundColor Yellow
        
        $requiredDirs = @("Modules", "Configs\Presets", "Outputs", "Logs", "Tests")
        foreach ($dir in $requiredDirs) {
            if (!(Test-Path $dir)) {
                New-Item -Path $dir -ItemType Directory -Force | Out-Null
                Write-Host "ディレクトリ作成: $dir" -ForegroundColor Yellow
            }
        }
        
        Write-Host "✅ 基本ディレクトリ構造確認完了" -ForegroundColor Green
    }
    
    Write-Host "=== 自動修復完了 ===" -ForegroundColor Green
}

# 使用例
# Repair-UnattendXMLGenerator -All
# Repair-UnattendXMLGenerator -ExecutionPolicy -FilePermissions
```

---

## パフォーマンス問題の対処

### 問題11: 実行速度が遅い

#### 症状
- XML生成に5分以上かかる
- スクリプト起動に時間がかかる
- システムが応答しなくなる

#### 診断方法

```powershell
# パフォーマンス診断スクリプト
function Test-PerformanceIssues {
    Write-Host "=== パフォーマンス診断 ===" -ForegroundColor Cyan
    
    # システムリソース確認
    $cpu = Get-WmiObject Win32_Processor
    $memory = Get-WmiObject Win32_ComputerSystem
    $disk = Get-WmiObject Win32_LogicalDisk | Where-Object { $_.DeviceID -eq "C:" }
    
    Write-Host "CPU: $($cpu.Name)" -ForegroundColor Gray
    Write-Host "CPU使用率: $($cpu.LoadPercentage)%" -ForegroundColor Gray
    Write-Host "メモリ: $([Math]::Round($memory.TotalPhysicalMemory / 1GB, 2))GB" -ForegroundColor Gray
    Write-Host "空きディスク: $([Math]::Round($disk.FreeSpace / 1GB, 2))GB" -ForegroundColor Gray
    
    # パフォーマンステスト
    $testResults = @{}
    
    # モジュールインポート時間
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    Import-Module ".\Generate-UnattendXML.psm1" -Force
    $stopwatch.Stop()
    $testResults.ModuleImportTime = $stopwatch.ElapsedMilliseconds
    Write-Host "モジュールインポート時間: $($testResults.ModuleImportTime)ms" -ForegroundColor Yellow
    
    # プリセット読み込み時間
    $stopwatch.Restart()
    $config = Import-UnattendPreset -PresetName "Development"
    $stopwatch.Stop()
    $testResults.PresetLoadTime = $stopwatch.ElapsedMilliseconds
    Write-Host "プリセット読み込み時間: $($testResults.PresetLoadTime)ms" -ForegroundColor Yellow
    
    # XML生成時間
    $stopwatch.Restart()
    $result = .\Generate-UnattendXML.ps1 -PresetName "Development" -OutputPath "perf-test.xml" -Force
    $stopwatch.Stop()
    $testResults.XMLGenerationTime = $stopwatch.ElapsedMilliseconds
    Write-Host "XML生成時間: $($testResults.XMLGenerationTime)ms" -ForegroundColor Yellow
    
    # テストファイル削除
    Remove-Item "perf-test.xml" -Force -ErrorAction SilentlyContinue
    
    # パフォーマンス評価
    Write-Host ""
    Write-Host "=== パフォーマンス評価 ===" -ForegroundColor Cyan
    
    if ($testResults.XMLGenerationTime -gt 30000) {  # 30秒以上
        Write-Host "❌ XML生成が非常に遅い（30秒超）" -ForegroundColor Red
        Write-Host "推奨対策: 並列度削減、メモリ増強、SSD使用" -ForegroundColor Yellow
    } elseif ($testResults.XMLGenerationTime -gt 10000) {  # 10秒以上
        Write-Host "⚠️ XML生成が遅い（10秒超）" -ForegroundColor Yellow
        Write-Host "推奨対策: 不要なプロセス終了、ウイルス対策ソフトの除外設定" -ForegroundColor Yellow
    } else {
        Write-Host "✅ XML生成速度は正常範囲" -ForegroundColor Green
    }
    
    return $testResults
}

# 使用例
Test-PerformanceIssues
```

#### 最適化方法

```powershell
# パフォーマンス最適化スクリプト
function Optimize-Performance {
    Write-Host "=== パフォーマンス最適化 ===" -ForegroundColor Cyan
    
    # 1. PowerShell優先度上昇
    $process = Get-Process -Id $PID
    $process.PriorityClass = "High"
    Write-Host "✅ PowerShellプロセス優先度を上昇させました" -ForegroundColor Green
    
    # 2. ガベージコレクション実行
    [System.GC]::Collect()
    [System.GC]::WaitForPendingFinalizers()
    [System.GC]::Collect()
    Write-Host "✅ メモリ最適化完了" -ForegroundColor Green
    
    # 3. 並列度調整
    $optimalParallelism = [Math]::Min([Environment]::ProcessorCount, 2)
    Write-Host "✅ 最適並列度設定: $optimalParallelism" -ForegroundColor Green
    
    # 4. 不要なモジュール削除
    Get-Module | Where-Object { $_.Name -notmatch "Generate-UnattendXML|Microsoft\.|System\." } | Remove-Module
    Write-Host "✅ 不要なモジュールを削除しました" -ForegroundColor Green
}

Optimize-Performance
```

---

## システム要件関連の問題

### 問題12: PowerShellバージョン不足

#### 症状
```
この操作には PowerShell 5.1 以降が必要です
```

#### 解決方法

```powershell
# PowerShellバージョン確認・アップグレード案内
function Test-PowerShellVersion {
    $currentVersion = $PSVersionTable.PSVersion
    $requiredVersion = [Version]"5.1.0"
    
    Write-Host "現在のPowerShellバージョン: $currentVersion" -ForegroundColor Yellow
    Write-Host "必要なバージョン: $requiredVersion以降" -ForegroundColor Yellow
    
    if ($currentVersion -ge $requiredVersion) {
        Write-Host "✅ PowerShellバージョンは要件を満たしています" -ForegroundColor Green
        return $true
    } else {
        Write-Host "❌ PowerShellバージョンが不足しています" -ForegroundColor Red
        Write-Host ""
        Write-Host "=== アップグレード方法 ===" -ForegroundColor Cyan
        Write-Host "Windows PowerShell 5.1のインストール:" -ForegroundColor White
        Write-Host "1. Windows Update経由でアップデート" -ForegroundColor Gray
        Write-Host "2. Windows Management Framework 5.1のダウンロードとインストール" -ForegroundColor Gray
        Write-Host "   https://www.microsoft.com/download/details.aspx?id=54616" -ForegroundColor Blue
        Write-Host ""
        Write-Host "PowerShell Core 7.x（推奨）:" -ForegroundColor White
        Write-Host "1. Microsoft Storeからインストール" -ForegroundColor Gray
        Write-Host "2. GitHubからダウンロード: https://github.com/PowerShell/PowerShell" -ForegroundColor Blue
        
        return $false
    }
}

Test-PowerShellVersion
```

---

### 問題13: .NET Framework不足

#### 症状
```
Add-Type : 次のアセンブリまたはモジュールを読み込めませんでした: 'System.Xml'
```

#### 解決方法

```powershell
# .NET Framework確認スクリプト
function Test-DotNetFramework {
    Write-Host "=== .NET Framework 診断 ===" -ForegroundColor Cyan
    
    try {
        # .NET Frameworkバージョン確認
        $netVersions = Get-ItemProperty "HKLM:SOFTWARE\Microsoft\NET Framework Setup\NDP\v*\" -ErrorAction SilentlyContinue |
                      Where-Object { $_.PSChildName -match '^(?!S)\d' } |
                      Select-Object PSChildName, Version, Release
        
        Write-Host "インストール済み .NET Framework バージョン:" -ForegroundColor Yellow
        $netVersions | Format-Table -AutoSize
        
        # .NET 4.7.2以降の確認（推奨）
        $net472Release = 461808
        $currentRelease = (Get-ItemProperty "HKLM:SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\" -ErrorAction SilentlyContinue).Release
        
        if ($currentRelease -ge $net472Release) {
            Write-Host "✅ .NET Framework 4.7.2以降がインストールされています" -ForegroundColor Green
        } else {
            Write-Host "⚠️ .NET Framework 4.7.2以降の推奨" -ForegroundColor Yellow
        }
        
        # アセンブリ読み込みテスト
        $testAssemblies = @(
            "System.Xml",
            "System.Security",
            "System.Management.Automation"
        )
        
        Write-Host ""
        Write-Host "アセンブリ読み込みテスト:" -ForegroundColor Yellow
        foreach ($assembly in $testAssemblies) {
            try {
                Add-Type -AssemblyName $assembly
                Write-Host "✅ $assembly" -ForegroundColor Green
            } catch {
                Write-Host "❌ $assembly - $_" -ForegroundColor Red
            }
        }
        
    } catch {
        Write-Host "❌ .NET Framework診断エラー: $_" -ForegroundColor Red
    }
}

Test-DotNetFramework
```

---

## サポートとヘルプの入手方法

### 1. セルフサポートツール

#### 統合ヘルプ表示
```powershell
# ヘルプ表示スクリプト
function Show-UnattendXMLHelp {
    param([string]$Topic = "All")
    
    switch ($Topic.ToLower()) {
        "parameters" {
            Write-Host "=== パラメーター一覧 ===" -ForegroundColor Cyan
            Get-Help .\Generate-UnattendXML.ps1 -Parameter *
        }
        "examples" {
            Write-Host "=== 使用例 ===" -ForegroundColor Cyan
            Get-Help .\Generate-UnattendXML.ps1 -Examples
        }
        "presets" {
            Write-Host "=== プリセット一覧 ===" -ForegroundColor Cyan
            $presets = Get-ChildItem ".\Configs\Presets" -Filter "*.psd1"
            foreach ($preset in $presets) {
                $name = $preset.BaseName
                Write-Host "- $name" -ForegroundColor Yellow
                
                $config = Import-PowerShellDataFile $preset.FullName
                if ($config.CustomSettings.Description) {
                    Write-Host "  説明: $($config.CustomSettings.Description)" -ForegroundColor Gray
                }
            }
        }
        "troubleshooting" {
            Write-Host "=== トラブルシューティング ===" -ForegroundColor Cyan
            Write-Host "1. 診断スクリプトの実行:" -ForegroundColor White
            Write-Host "   Start-CompleteDiagnosis -Detailed" -ForegroundColor Gray
            Write-Host ""
            Write-Host "2. 最新ログの確認:" -ForegroundColor White
            Write-Host "   Analyze-LatestLog" -ForegroundColor Gray
            Write-Host ""
            Write-Host "3. 自動修復の実行:" -ForegroundColor White
            Write-Host "   Repair-UnattendXMLGenerator -All" -ForegroundColor Gray
        }
        default {
            Write-Host "=== Windows 11 UnattendXML Generator ヘルプ ===" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "利用可能なヘルプトピック:" -ForegroundColor Yellow
            Write-Host "- parameters : コマンドパラメーター詳細" -ForegroundColor White
            Write-Host "- examples   : 使用例" -ForegroundColor White
            Write-Host "- presets    : プリセット一覧" -ForegroundColor White
            Write-Host "- troubleshooting : トラブルシューティング" -ForegroundColor White
            Write-Host ""
            Write-Host "使用例:" -ForegroundColor Yellow
            Write-Host "Show-UnattendXMLHelp -Topic parameters" -ForegroundColor Gray
        }
    }
}

# 使用例
# Show-UnattendXMLHelp
# Show-UnattendXMLHelp -Topic presets
```

### 2. ログ収集スクリプト

```powershell
# サポート用情報収集スクリプト
function Collect-SupportInformation {
    param([string]$OutputPath = "support-info.txt")
    
    $info = @()
    $info += "=== Windows 11 UnattendXML Generator サポート情報 ==="
    $info += "収集日時: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
    $info += ""
    
    # システム情報
    $info += "=== システム情報 ==="
    $info += "OS: $((Get-WmiObject Win32_OperatingSystem).Caption)"
    $info += "バージョン: $((Get-WmiObject Win32_OperatingSystem).Version)"
    $info += "アーキテクチャ: $env:PROCESSOR_ARCHITECTURE"
    $info += "PowerShell: $($PSVersionTable.PSVersion)"
    $info += "実行ポリシー: $(Get-ExecutionPolicy)"
    $info += ""
    
    # エラー情報（最新ログから）
    $info += "=== 最新エラー情報 ==="
    $latestLog = Get-ChildItem ".\Logs" -Filter "*.log" -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
    if ($latestLog) {
        $errors = Get-Content $latestLog.FullName | Where-Object { $_ -match "\[Error\]|\[Critical\]" } | Select-Object -Last 10
        if ($errors) {
            $info += $errors
        } else {
            $info += "最近のエラーはありません"
        }
    } else {
        $info += "ログファイルが見つかりません"
    }
    $info += ""
    
    # ファイル構成情報
    $info += "=== ファイル構成情報 ==="
    $requiredFiles = @(
        ".\Generate-UnattendXML.ps1",
        ".\Generate-UnattendXML.psm1",
        ".\Configs\Presets\Development.psd1",
        ".\Configs\Presets\Enterprise.psd1",
        ".\Configs\Presets\Minimal.psd1"
    )
    
    foreach ($file in $requiredFiles) {
        $exists = Test-Path $file
        $size = if ($exists) { (Get-Item $file).Length } else { "N/A" }
        $info += "$file : $(if($exists){'✅'}else{'❌'}) ($size bytes)"
    }
    
    # ファイル出力
    $info | Out-File $OutputPath -Encoding UTF8
    Write-Host "サポート情報を収集しました: $OutputPath" -ForegroundColor Green
}

# 使用例
Collect-SupportInformation -OutputPath "my-support-info.txt"
```

### 3. コミュニティサポート

#### GitHubリポジトリ
- **Issues**: バグレポートや機能要求
- **Discussions**: 質問や使用方法の相談
- **Wiki**: 詳細なドキュメントと事例

#### 推奨される質問の仕方
1. **環境情報の明記**
   - OS バージョン
   - PowerShell バージョン  
   - システムアーキテクチャ

2. **エラー情報の詳細**
   - 完全なエラーメッセージ
   - 実行したコマンド
   - 期待した結果と実際の結果

3. **再現手順**
   - 問題が発生するまでの具体的な手順
   - 使用した設定ファイル（機密情報を除く）

#### サポート情報の例
```
## 環境
- OS: Windows 11 Pro 22H2
- PowerShell: 5.1.19041.2364
- システム: x64

## 問題
XMLファイル生成時に以下のエラーが発生

## エラーメッセージ
```
System.Xml.XmlException: 不正な文字が含まれています
```

## 実行コマンド
```powershell
.\Generate-UnattendXML.ps1 -PresetName Enterprise -OutputPath ".\test.xml"
```

## 追加情報
- 診断スクリプト結果: （添付ファイル）
- 使用した設定: Enterprise プリセット（変更なし）
```

---

### まとめ

このトラブルシューティングガイドでは、Windows 11 Sysprep応答ファイル自動生成システム（PowerShell版）で発生する可能性のある問題と、その解決方法を体系的に整理しました。

**効果的なトラブルシューティングのポイント**:

1. **段階的診断**: Level 1（基本確認）→ Level 2（詳細確認）→ Level 3（機能テスト）の順序で問題を特定
2. **ログ活用**: 詳細なログ解析により根本原因を特定
3. **自動化ツール**: 診断・修復スクリプトを活用した効率的な問題解決
4. **予防策**: 定期的な診断とメンテナンスによる問題の事前防止

問題が解決しない場合は、サポート情報収集スクリプトを実行し、詳細な情報と共にコミュニティに相談することを推奨します。