# PowerShell版 v2.0 トラブルシューティングガイド

## 目次
1. [よくある問題と解決方法](#よくある問題と解決方法)
2. [エラーメッセージ対応表](#エラーメッセージ対応表)
3. [SubAgent関連の問題](#subagent関連の問題)
4. [Claude-flow並列処理の問題](#claude-flow並列処理の問題)
5. [XML生成エラー](#xml生成エラー)
6. [パフォーマンス問題](#パフォーマンス問題)
7. [設定関連の問題](#設定関連の問題)
8. [診断ツールの使用](#診断ツールの使用)
9. [ログ分析](#ログ分析)
10. [緊急時の対処法](#緊急時の対処法)

---

## よくある問題と解決方法

### 1. スクリプト実行エラー

#### 問題: 「このシステムではスクリプトの実行が無効になっています」
```
.\Generate-UnattendXML-V2.ps1 : このシステムではスクリプトの実行が無効になっているため、
ファイル Generate-UnattendXML-V2.ps1 を読み込むことができません。
```

**解決方法:**
```powershell
# 実行ポリシーの確認
Get-ExecutionPolicy

# 実行ポリシーを変更（管理者権限）
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force

# または一時的に実行
powershell.exe -ExecutionPolicy Bypass -File ".\Generate-UnattendXML-V2.ps1"
```

---

### 2. モジュール読み込みエラー

#### 問題: 「指定されたモジュールが見つかりません」
```
Import-Module : 指定されたモジュール 'ClaudeFlow' が読み込まれませんでした。
```

**解決方法:**
```powershell
# モジュールパスの確認
Test-Path ".\Modules\ClaudeFlow\ClaudeFlow.psm1"

# モジュールパスを追加
$env:PSModulePath += ";$(Get-Location)\Modules"

# 手動でモジュールをインポート
Import-Module ".\Modules\ClaudeFlow\ClaudeFlow.psm1" -Force -Verbose

# すべてのモジュールを再インポート
Get-ChildItem ".\Modules" -Directory | ForEach-Object {
    Import-Module "$($_.FullName)\$($_.Name).psm1" -Force
}
```

---

### 3. 権限不足エラー

#### 問題: 「アクセスが拒否されました」
```
New-Item : パス 'C:\Program Files\' へのアクセスが拒否されました。
```

**解決方法:**
```powershell
# 管理者権限で実行
Start-Process powershell -Verb RunAs -ArgumentList "-File `"$PWD\Generate-UnattendXML-V2.ps1`""

# 現在のユーザーが管理者か確認
$isAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
if (-not $isAdmin) {
    Write-Warning "管理者権限で実行してください"
    exit
}

# 別の出力先を指定
.\Generate-UnattendXML-V2.ps1 -OutputPath "$env:TEMP\unattend.xml"
```

---

### 4. メモリ不足エラー

#### 問題: 「使用可能なメモリが不足しています」
```
Exception: There is not enough memory to complete the operation
```

**解決方法:**
```powershell
# メモリ使用状況の確認
Get-Process powershell* | Select-Object Name, @{n='Memory(MB)';e={$_.WorkingSet64/1MB}}

# ガベージコレクションの実行
[System.GC]::Collect()
[System.GC]::WaitForPendingFinalizers()
[System.GC]::Collect()

# スレッド数を減らして実行
.\Generate-UnattendXML-V2.ps1 -Preset Enterprise -MaxThreads 2

# メモリ制限の設定
$MaxMemory = 512MB
if ((Get-Process -Id $PID).WorkingSet64 -gt $MaxMemory) {
    Write-Warning "メモリ使用量が制限を超えています"
}
```

---

## エラーメッセージ対応表

### PowerShellエラー

| エラーメッセージ | 原因 | 解決方法 |
|-----------------|------|----------|
| `The term is not recognized` | コマンドレットが見つからない | モジュールをインポート |
| `Cannot bind parameter` | パラメータエラー | パラメータ名と値を確認 |
| `Cannot convert value` | 型変換エラー | データ型を確認 |
| `The property cannot be found` | プロパティが存在しない | オブジェクト構造を確認 |
| `Access to the path is denied` | ファイルアクセス権限なし | 管理者権限で実行 |

### システムエラー

| エラーコード | 説明 | 対処法 |
|-------------|------|--------|
| 0x80070005 | アクセス拒否 | 管理者権限で実行 |
| 0x80070057 | パラメータが正しくない | 設定値を確認 |
| 0x800703E3 | 操作が中断された | 再実行または再起動 |
| 0x80004005 | 未指定のエラー | イベントログを確認 |

---

## SubAgent関連の問題

### 1. SubAgentが起動しない

**症状:**
```
SubAgent 'UserCreationAgent' の初期化に失敗しました
```

**診断手順:**
```powershell
# SubAgentの個別テスト
$agent = New-SubAgent -Name "UserCreationAgent" -Category "UserManagement"
$agent.Initialize(@{Debug = $true})

# エラー詳細の確認
$Error[0] | Format-List -Force

# 依存関係の確認
Test-SubAgentDependencies -AgentName "UserCreationAgent"
```

**解決方法:**
```powershell
# SubAgentモジュールの再読み込み
Remove-Module SubAgentLoader -Force -ErrorAction SilentlyContinue
Import-Module ".\Modules\SubAgentLoader\SubAgentLoader.psm1" -Force

# キャッシュのクリア
Remove-Item ".\Cache\SubAgents\*" -Force -ErrorAction SilentlyContinue

# 個別実行モードで起動
.\Generate-UnattendXML-V2.ps1 -DisableSubAgents -Preset Minimal
```

### 2. SubAgent間の依存関係エラー

**症状:**
```
Dependency 'NetworkConfigAgent' not satisfied for 'DomainJoinAgent'
```

**解決方法:**
```powershell
# 依存関係マップの確認
Get-SubAgentDependencyMap | Format-Table -AutoSize

# 実行順序の手動指定
$executionOrder = @(
    "NetworkConfigAgent",
    "TimeZoneAgent",
    "DomainJoinAgent"
)

.\Generate-UnattendXML-V2.ps1 -AgentExecutionOrder $executionOrder
```

---

## Claude-flow並列処理の問題

### 1. RunspacePoolエラー

**症状:**
```
RunspacePool の初期化に失敗しました: Cannot create runspace pool
```

**診断:**
```powershell
# 現在のRunspace状態確認
Get-Runspace | Select-Object Id, RunspaceStateInfo, Availability

# RunspacePoolの手動作成テスト
$rsPool = [RunspaceFactory]::CreateRunspacePool(1, 4)
$rsPool.Open()
$rsPool.GetAvailableRunspaces()
$rsPool.Close()
```

**解決方法:**
```powershell
# シングルスレッドモードで実行
.\Generate-UnattendXML-V2.ps1 -DisableParallel

# RunspacePoolサイズを調整
.\Generate-UnattendXML-V2.ps1 -MaxThreads 2 -MinThreads 1

# セッション状態をリセット
[System.Management.Automation.Runspaces.Runspace]::DefaultRunspace = $null
```

### 2. デッドロック

**症状:**
```
スクリプトが応答しなくなり、進行状況が更新されない
```

**診断と解決:**
```powershell
# タイムアウト付き実行
$job = Start-Job -ScriptBlock {
    & ".\Generate-UnattendXML-V2.ps1" -Preset Enterprise
}

# 5分待機
Wait-Job $job -Timeout 300

if ($job.State -eq "Running") {
    Stop-Job $job -Force
    Write-Warning "タイムアウトのためジョブを強制終了しました"
}

# デバッグモードで詳細確認
.\Generate-UnattendXML-V2.ps1 -Debug -Verbose -MaxThreads 1
```

---

## XML生成エラー

### 1. XML検証エラー

**症状:**
```
XML Schema validation failed: The element 'component' has invalid child element
```

**診断:**
```powershell
# 生成されたXMLの検証
[xml]$xml = Get-Content ".\Outputs\unattend.xml"
Test-UnattendXMLSchema -XmlPath ".\Outputs\unattend.xml"

# XML構造の確認
$xml.unattend.settings | ForEach-Object {
    Write-Host "Pass: $($_.pass)"
    $_.component | ForEach-Object {
        Write-Host "  Component: $($_.name)"
    }
}
```

**解決方法:**
```powershell
# スキーマ検証を無効化（一時的）
.\Generate-UnattendXML-V2.ps1 -SkipValidation

# XMLの手動修正
$xml = [xml](Get-Content ".\Outputs\unattend.xml")
# 問題のある要素を修正
$xml.Save(".\Outputs\unattend_fixed.xml")

# クリーンな設定で再生成
.\Generate-UnattendXML-V2.ps1 -Preset Minimal -CleanMode
```

### 2. エンコーディングエラー

**症状:**
```
パスワードが正しくエンコードされない、文字化けする
```

**解決方法:**
```powershell
# UTF-16LEエンコーディングの確認
function Test-PasswordEncoding {
    param($Password)
    
    $bytes = [System.Text.Encoding]::Unicode.GetBytes($Password + "Password")
    $encoded = [Convert]::ToBase64String($bytes)
    
    Write-Host "Original: $Password"
    Write-Host "Encoded: $encoded"
    
    # デコードテスト
    $decoded = [System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($encoded))
    Write-Host "Decoded: $decoded"
}

Test-PasswordEncoding -Password "TestPass123!"
```

---

## パフォーマンス問題

### 1. 処理速度が遅い

**診断:**
```powershell
# パフォーマンス測定
Measure-Command {
    .\Generate-UnattendXML-V2.ps1 -Preset Enterprise
} | Select-Object TotalSeconds

# ボトルネックの特定
.\Generate-UnattendXML-V2.ps1 -EnableProfiling -ProfileOutput ".\profile.log"
```

**最適化方法:**
```powershell
# キャッシュ有効化
.\Generate-UnattendXML-V2.ps1 -EnableCache -CachePath ".\Cache"

# 不要な機能を無効化
$config = @{
    DisableLogging = $true
    DisableValidation = $true
    MinimalOutput = $true
}
.\Generate-UnattendXML-V2.ps1 -Config $config

# プロセス優先度の設定
$process = Get-Process -Id $PID
$process.PriorityClass = "AboveNormal"
```

### 2. メモリ使用量が多い

**診断:**
```powershell
# メモリプロファイリング
function Get-MemoryUsage {
    $process = Get-Process -Id $PID
    @{
        WorkingSet = [math]::Round($process.WorkingSet64 / 1MB, 2)
        PrivateMemory = [math]::Round($process.PrivateMemorySize64 / 1MB, 2)
        VirtualMemory = [math]::Round($process.VirtualMemorySize64 / 1MB, 2)
    }
}

# 実行前後で比較
$before = Get-MemoryUsage
.\Generate-UnattendXML-V2.ps1 -Preset Minimal
$after = Get-MemoryUsage

Write-Host "Memory Delta: $($after.WorkingSet - $before.WorkingSet) MB"
```

---

## 設定関連の問題

### 1. 設定ファイルが読み込めない

**症状:**
```
Cannot load configuration file: Invalid JSON/PSD1 format
```

**診断と修正:**
```powershell
# JSON検証
try {
    $json = Get-Content ".\config.json" -Raw | ConvertFrom-Json
    Write-Host "JSONは有効です" -ForegroundColor Green
}
catch {
    Write-Host "JSONエラー: $_" -ForegroundColor Red
    
    # JSONLintで詳細確認
    $lineNumber = $_.Exception.Message -match 'line (\d+)' | Out-Null
    if ($Matches[1]) {
        Get-Content ".\config.json" | Select-Object -Skip ($Matches[1] - 2) -First 5
    }
}

# PSD1検証
try {
    $psd1 = Import-PowerShellDataFile ".\config.psd1"
    Write-Host "PSD1は有効です" -ForegroundColor Green
}
catch {
    Write-Host "PSD1エラー: $_" -ForegroundColor Red
}
```

### 2. プリセットが適用されない

**症状:**
```
プリセット 'Enterprise' の設定が反映されない
```

**解決方法:**
```powershell
# プリセットファイルの確認
Test-Path ".\Configs\Presets\Enterprise.psd1"

# プリセットの手動読み込み
$preset = Import-PowerShellDataFile ".\Configs\Presets\Enterprise.psd1"
$preset | ConvertTo-Json -Depth 5

# プリセットのリセット
Copy-Item ".\Configs\Presets\Enterprise.psd1.backup" ".\Configs\Presets\Enterprise.psd1" -Force

# カスタムプリセットとして使用
.\Generate-UnattendXML-V2.ps1 -ConfigFile ".\Configs\Presets\Enterprise.psd1"
```

---

## 診断ツールの使用

### 1. 組み込み診断コマンド

```powershell
# システム診断
.\Generate-UnattendXML-V2.ps1 -Diagnose

# 出力例：
# ========================================
# PowerShell診断レポート
# ========================================
# PowerShell Version: 5.1.22621.2506
# OS Version: Microsoft Windows 11 Pro
# Memory Available: 8192 MB
# CPU Cores: 8
# Execution Policy: RemoteSigned
# 
# モジュール状態:
# ✓ ClaudeFlow: OK
# ✓ Context7: OK
# ✓ SubAgentLoader: OK
# ✓ XMLGeneratorV2: OK
# 
# SubAgent状態 (42/42):
# ✓ All agents initialized
# ========================================
```

### 2. 詳細診断スクリプト

```powershell
# 診断スクリプトの実行
.\Tests\Run-Diagnostics.ps1 -Full

# 特定コンポーネントの診断
.\Tests\Test-SubAgents.ps1
.\Tests\Test-ClaudeFlow.ps1
.\Tests\Test-XMLGeneration.ps1
```

### 3. ヘルスチェック

```powershell
function Test-SystemHealth {
    $health = @{
        PowerShell = $PSVersionTable.PSVersion.Major -ge 5
        Memory = (Get-CimInstance Win32_OperatingSystem).FreePhysicalMemory -gt 1GB
        DiskSpace = (Get-PSDrive C).Free -gt 1GB
        AdminRights = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
    }
    
    $health.GetEnumerator() | ForEach-Object {
        $status = if ($_.Value) { "✓" } else { "✗" }
        $color = if ($_.Value) { "Green" } else { "Red" }
        Write-Host "$status $($_.Key): $($_.Value)" -ForegroundColor $color
    }
    
    return $health.Values -notcontains $false
}

if (-not (Test-SystemHealth)) {
    Write-Warning "システムヘルスチェックに失敗しました"
}
```

---

## ログ分析

### 1. ログレベル別の確認

```powershell
# エラーログのみ抽出
Get-Content ".\Logs\*.log" | Select-String "ERROR" | Select-Object -Last 20

# 警告とエラーの集計
$logs = Get-Content ".\Logs\*.log"
$summary = @{
    Errors = ($logs | Select-String "ERROR").Count
    Warnings = ($logs | Select-String "WARNING").Count
    Info = ($logs | Select-String "INFO").Count
}
$summary
```

### 2. タイムスタンプ分析

```powershell
# 処理時間の分析
$pattern = '\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]'
$timestamps = Get-Content ".\Logs\latest.log" | 
    Where-Object { $_ -match $pattern } | 
    ForEach-Object { [datetime]$Matches[1] }

if ($timestamps.Count -gt 1) {
    $duration = $timestamps[-1] - $timestamps[0]
    Write-Host "Total execution time: $($duration.TotalSeconds) seconds"
}
```

### 3. エラーパターン分析

```powershell
# よくあるエラーパターンの検出
$errorPatterns = @{
    "Memory" = "OutOfMemory|memory"
    "Permission" = "Access.*denied|Unauthorized"
    "Network" = "network|connection"
    "Module" = "module|import"
}

$logContent = Get-Content ".\Logs\*.log" -Raw
foreach ($pattern in $errorPatterns.GetEnumerator()) {
    $matches = [regex]::Matches($logContent, $pattern.Value, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
    if ($matches.Count -gt 0) {
        Write-Host "$($pattern.Key) errors found: $($matches.Count)" -ForegroundColor Yellow
    }
}
```

---

## 緊急時の対処法

### 1. 完全リセット

```powershell
# すべてのキャッシュとテンポラリファイルをクリア
function Reset-Environment {
    Write-Host "環境をリセットしています..." -ForegroundColor Yellow
    
    # プロセスの停止
    Get-Process powershell* | Where-Object { $_.Id -ne $PID } | Stop-Process -Force
    
    # キャッシュクリア
    Remove-Item ".\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue
    Remove-Item ".\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue
    Remove-Item "$env:TEMP\UnattendXML_*" -Force -ErrorAction SilentlyContinue
    
    # モジュールのアンロード
    Get-Module | Where-Object { $_.Path -like "*\Modules\*" } | Remove-Module -Force
    
    # ガベージコレクション
    [System.GC]::Collect()
    [System.GC]::WaitForPendingFinalizers()
    [System.GC]::Collect()
    
    Write-Host "リセット完了" -ForegroundColor Green
}

Reset-Environment
```

### 2. セーフモード実行

```powershell
# 最小限の機能で実行
function Start-SafeMode {
    $safeConfig = @{
        Preset = "Minimal"
        DisableParallel = $true
        DisableSubAgents = $true
        SkipValidation = $true
        MaxThreads = 1
        LogLevel = "Error"
    }
    
    Write-Host "セーフモードで実行中..." -ForegroundColor Yellow
    & ".\Generate-UnattendXML-V2.ps1" @safeConfig
}

Start-SafeMode
```

### 3. リカバリーモード

```powershell
# バックアップからの復元
function Start-Recovery {
    param(
        [string]$BackupPath = ".\Backups\latest"
    )
    
    if (Test-Path $BackupPath) {
        Write-Host "バックアップから復元中..." -ForegroundColor Yellow
        
        # 設定ファイルの復元
        Copy-Item "$BackupPath\Configs\*" ".\Configs\" -Recurse -Force
        
        # モジュールの復元
        Copy-Item "$BackupPath\Modules\*" ".\Modules\" -Recurse -Force
        
        Write-Host "復元完了" -ForegroundColor Green
    }
    else {
        Write-Warning "バックアップが見つかりません: $BackupPath"
    }
}

Start-Recovery
```

### 4. 最終手段

```powershell
# 完全な再インストール
function Reinstall-System {
    Write-Warning "システムを再インストールします。続行しますか？ (Y/N)"
    $confirm = Read-Host
    
    if ($confirm -eq 'Y') {
        # GitHubから最新版をダウンロード
        $url = "https://github.com/your-repo/archive/main.zip"
        $temp = "$env:TEMP\powershell-v2.zip"
        
        Invoke-WebRequest -Uri $url -OutFile $temp
        Expand-Archive -Path $temp -DestinationPath ".\" -Force
        
        Write-Host "再インストール完了。新しいPowerShellセッションで実行してください。" -ForegroundColor Green
    }
}
```

---

## サポート情報

### ログ収集スクリプト

```powershell
# サポート用ログ収集
function Collect-SupportLogs {
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $supportPath = ".\Support_$timestamp"
    
    New-Item -ItemType Directory -Path $supportPath -Force
    
    # システム情報
    Get-ComputerInfo | Out-File "$supportPath\system_info.txt"
    
    # PowerShell情報
    $PSVersionTable | Out-File "$supportPath\powershell_info.txt"
    
    # ログファイル
    Copy-Item ".\Logs\*" "$supportPath\Logs\" -Recurse
    
    # 設定ファイル（機密情報を除く）
    Get-ChildItem ".\Configs\*.json", ".\Configs\*.psd1" | ForEach-Object {
        $content = Get-Content $_.FullName | 
            ForEach-Object { $_ -replace 'password.*?["\'].*?["\']', 'password": "***"' }
        $content | Out-File "$supportPath\Configs\$($_.Name)"
    }
    
    # 圧縮
    Compress-Archive -Path $supportPath -DestinationPath ".\Support_$timestamp.zip"
    Remove-Item $supportPath -Recurse -Force
    
    Write-Host "サポートログを作成しました: Support_$timestamp.zip" -ForegroundColor Green
}

Collect-SupportLogs
```

---

## 次のステップ

1. **[開発完了報告書.md](./開発完了報告書.md)** - v2.0開発完了報告
2. **[SubAgentリファレンス.md](./SubAgentリファレンス.md)** - エージェントの詳細
3. **[詳細利用手順書_v2.md](./詳細利用手順書_v2.md)** - 通常の使用方法

---

## お問い合わせ

技術的な問題が解決しない場合は、以下の情報を添えてサポートにお問い合わせください：

1. エラーメッセージの全文
2. 実行したコマンド
3. サポートログ（Collect-SupportLogsで生成）
4. 環境情報（OS、PowerShellバージョン）

---

*最終更新: 2024年8月24日 | バージョン: 2.0.0*